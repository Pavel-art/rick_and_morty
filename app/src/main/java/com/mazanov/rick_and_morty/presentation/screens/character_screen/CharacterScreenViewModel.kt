package com.mazanov.rick_and_morty.presentation.screens.character_screenimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport com.mazanov.rick_and_morty.domain.models.PersonModelimport com.mazanov.rick_and_morty.domain.useCases.AddPersonToDatabaseUseCaseimport com.mazanov.rick_and_morty.domain.useCases.GetAllPersonsFromDatabaseUseCaseimport com.mazanov.rick_and_morty.presentation.screens.fovourite_screen.FavouriteScreenStateimport dagger.hilt.android.lifecycle.HiltViewModelimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.flow.*import kotlinx.coroutines.launchimport javax.inject.Inject@HiltViewModelclass CharacterScreenViewModel @Inject constructor(    private val addPersonToDatabaseUseCase: AddPersonToDatabaseUseCase,    private val getAllPersonsFromDatabaseUseCase: GetAllPersonsFromDatabaseUseCase) : ViewModel() {    private var _state = MutableLiveData<FavouriteScreenState>(FavouriteScreenState.InitState)    val state: LiveData<FavouriteScreenState> = _state////    init {//        getFavouritePersons()//    }    fun addPersonToFavourite(person: PersonModel) {        viewModelScope.launch(Dispatchers.IO) {            addPersonToDatabaseUseCase.invoke(person)            getFavouritePersons()        }    }     fun getFavouritePersons() {        viewModelScope.launch{            getAllPersonsFromDatabaseUseCase.invoke()                .filter { it.isNotEmpty() }                .onStart { _state.value = FavouriteScreenState.LoadingState }                .onEach { _state.value = FavouriteScreenState.LoadSate(content = it) }                .launchIn(viewModelScope)        }    }}//try {//    getAllCharactersUseCase.invoke(page)//        .onStart { _isNextPage.value = false }//        .filter { it.isNotEmpty() }//        .onEach { response ->//            _mainScreenState.value = MainScreenState.Load(content = response)//            _persons.value = response//            _isRefreshing.emit(false)//        }//        .launchIn(viewModelScope)//} catch (error: Exception) {//    _mainScreenState.value = MainScreenState.Error(exception = error.message.toString())//}