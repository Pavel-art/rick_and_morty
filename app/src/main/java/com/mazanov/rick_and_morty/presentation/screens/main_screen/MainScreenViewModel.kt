package com.mazanov.rick_and_morty.presentation.screens.main_screenimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport com.mazanov.rick_and_morty.domain.models.PersonModelimport com.mazanov.rick_and_morty.domain.models.PersonModel.Companion.TOTAL_PAGESimport com.mazanov.rick_and_morty.domain.useCases.GetAllCharactersUseCaseimport dagger.hilt.android.lifecycle.HiltViewModelimport kotlinx.coroutines.FlowPreviewimport kotlinx.coroutines.flow.*import javax.inject.Inject@OptIn(FlowPreview::class)@HiltViewModelclass MainScreenViewModel @Inject constructor(    private val getAllCharactersUseCase: GetAllCharactersUseCase) : ViewModel() {    private val _mainScreenState = MutableLiveData<MainScreenState>(MainScreenState.Initial)    val mainScreenState = _mainScreenState    private var _isNextPage = MutableLiveData(false)    val isNextPage: LiveData<Boolean> = _isNextPage    private val _page = MutableLiveData(1)    private val _searchText = MutableStateFlow("")    val searchText = _searchText.asStateFlow()    private val _isSearchOpen= MutableStateFlow(false)    val isSearchOpen=_isSearchOpen.asStateFlow()    init {        _mainScreenState.value = MainScreenState.Loading        getAllCharactersFromRepository()    }    private val _persons = MutableStateFlow(emptyList<PersonModel>())    val persons = searchText        .debounce(1000L)        .onEach { mainScreenState.value = MainScreenState.Loading}        .combine(_persons) { text, persons ->            if(text.isBlank()) {                persons            } else {                persons.filter {                    it.doesMatchSearchQuery(text)                }            }        }        .onEach { _mainScreenState.value = MainScreenState.Load( content = _persons.value)}        .stateIn(            viewModelScope,            SharingStarted.WhileSubscribed(5000),            _persons.value        )    fun onSearchTextChange(text: String) {        _searchText.value = text    }    fun searchReset() {        _searchText.value = ""        _persons.value = emptyList()         getAllCharactersFromRepository()    }    fun isOpenCloseSearch () {        _isSearchOpen.value = !_isSearchOpen.value    }    private fun getAllCharactersFromRepository(page: Int = _page.value ?: 1) {        try {            getAllCharactersUseCase.invoke(page)                .onStart { _isNextPage.value = false }                .filter { it.isNotEmpty() }                .onEach { response ->                    _mainScreenState.value = MainScreenState.Load(content = response)                    _persons.value = response                }                .launchIn(viewModelScope)        } catch (error: Exception) {            _mainScreenState.value = MainScreenState.Error(exception = error.message.toString())        }    }    fun getNextPage() {        if (requireNotNull(_page.value) < TOTAL_PAGES) {            val nexPage = nextCountPage()            _isNextPage.value = true            getAllCharactersFromRepository(nexPage)        }    }    private fun nextCountPage(): Int {        if (requireNotNull(_page.value) < TOTAL_PAGES) {            _page.value = _page.value?.plus(1)        }        return _page.value ?: 1    }}